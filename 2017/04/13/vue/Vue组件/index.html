<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="vue,data函数," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="组件可扩展html元素，封装重用代码  组件的使用##注册要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如：123Vue.component(&amp;apos;my-component&amp;apos;, &amp;#123;  // 选项&amp;#125;)  W3C规则：小写，并且包含一个短杠  组件在注册之后，便可以在父实例的模块中以自定义元素  的形式使用。要">
<meta name="keywords" content="vue,data函数">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue组件">
<meta property="og:url" content="http://yoursite.com/2017/04/13/vue/Vue组件/index.html">
<meta property="og:site_name" content="捡来·放去">
<meta property="og:description" content="组件可扩展html元素，封装重用代码  组件的使用##注册要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如：123Vue.component(&amp;apos;my-component&amp;apos;, &amp;#123;  // 选项&amp;#125;)  W3C规则：小写，并且包含一个短杠  组件在注册之后，便可以在父实例的模块中以自定义元素  的形式使用。要">
<meta property="og:image" content="https://cn.vuejs.org/images/props-events.png">
<meta property="og:updated_time" content="2017-04-13T09:04:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue组件">
<meta name="twitter:description" content="组件可扩展html元素，封装重用代码  组件的使用##注册要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如：123Vue.component(&amp;apos;my-component&amp;apos;, &amp;#123;  // 选项&amp;#125;)  W3C规则：小写，并且包含一个短杠  组件在注册之后，便可以在父实例的模块中以自定义元素  的形式使用。要">
<meta name="twitter:image" content="https://cn.vuejs.org/images/props-events.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/13/vue/Vue组件/"/>





  <title> Vue组件 | 捡来·放去 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">捡来·放去</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-pic">
          <a href="/pic" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-blog">
          <a href="/blog" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            博客
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/vue/Vue组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChrisLanbo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="捡来·放去">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Vue组件
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T15:31:48+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index">
                    <span itemprop="name">vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>组件可扩展html元素，封装重用代码</p>
</blockquote>
<h1 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h1><p>##注册<br>要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;my-component&apos;, &#123;</div><div class="line">  // 选项</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>W3C规则：小写，并且包含一个短杠</p>
</blockquote>
<p>组件在注册之后，便可以在父实例的模块中以自定义元素 <my-component></my-component> 的形式使用。要确保在初始化根实例 之前 注册了组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;example&quot;&gt;</div><div class="line">  &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">// 注册</div><div class="line">Vue.component(&apos;my-component&apos;, &#123;</div><div class="line">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</div><div class="line">&#125;)</div><div class="line">// 创建根实例</div><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#example&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>会渲染成===&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;example&quot;&gt;</div><div class="line">  &lt;div&gt;A custom component!&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><p>不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var Child = &#123;</div><div class="line">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</div><div class="line">&#125;</div><div class="line">new Vue(&#123;</div><div class="line">  // ...</div><div class="line">  components: &#123;</div><div class="line">    // &lt;my-component&gt; 将只在父模板可用</div><div class="line">    &apos;my-component&apos;: Child</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>这种封装也适用于其它可注册的 Vue 功能，如指令。</p>
</blockquote>
<h2 id="DOM模版"><a href="#DOM模版" class="headerlink" title="DOM模版"></a>DOM模版</h2><p>使用 DOM 作为模版时（例如，将 el 选项挂载到一个已存在的元素上）, 你会受到 HTML 的一些限制，因为 Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。尤其像这些元素<br><code>&lt;ul&gt; ， &lt;ol&gt;， &lt;table&gt; ， &lt;select&gt;</code>限制了能被它包裹的元素，<code>&lt;option&gt;</code>只能出现在其它元素内部。<br>在自定义组件中使用这些受限制的元素时会导致一些问题，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line"> &lt;my-row&gt;...&lt;/my-row&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure>
<p>自定义组件 <my-row> 被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 is 属性：</my-row></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line"> &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure>
<h2 id="data必须是函数"><a href="#data必须是函数" class="headerlink" title="data必须是函数"></a>data必须是函数</h2><p>Vue构造器传入选项大多数都可以在组件使用。 data 是一个例外，它必须是函数。 错误做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;my-component&apos;, &#123;</div><div class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message: &apos;hello&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>那么 Vue 会停止，并在控制台发出警告，告诉你在组件中 data 必须是一个函数。理解这种规则的存在意义很有帮助，让我们假设用如下方式来绕开Vue的警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;example-2&quot;&gt;</div><div class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</div><div class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</div><div class="line">  &lt;simple-counter&gt;&lt;/simple-counter&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">var data = &#123; counter: 0 &#125;</div><div class="line">Vue.component(&apos;simple-counter&apos;, &#123;</div><div class="line">  template: &apos;&lt;button v-on:click=&quot;counter += 1&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</div><div class="line">  // 技术上 data 的确是一个函数了，因此 Vue 不会警告，</div><div class="line">  // 但是我们返回给每个组件的实例的却引用了同一个data对象</div><div class="line">  data: function () &#123;</div><div class="line">    return data</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#example-2&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>由于这三个组件共享了同一个 data ， 因此增加一个 counter 会影响所有组件！这不对。我们可以通过为每个组件返回全新的 data 对象来解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data: function () &#123;</div><div class="line">  return &#123;</div><div class="line">    counter: 0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件<br> Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。</p>
<p><img src="https://cn.vuejs.org/images/props-events.png" alt=""></p>
<h1 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h1><h2 id="使用props传递数据"><a href="#使用props传递数据" class="headerlink" title="使用props传递数据"></a>使用props传递数据</h2><p>组件实例相互独立，不能在子控件直接引用父控件数据，需要通过子组件的props选项<br>子组件要显式地用 props 选项声明它期待获得的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;child&apos;, &#123;</div><div class="line">  // 声明 props</div><div class="line">  props: [&apos;message&apos;],</div><div class="line">  // 就像 data 一样，prop 可以用在模板内</div><div class="line">  // 同样也可以在 vm 实例中像 “this.message” 这样使用</div><div class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然后我们可以这样向它传入一个普通字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt;</div></pre></td></tr></table></figure>
<h2 id="驼峰式和短横线隔开式"><a href="#驼峰式和短横线隔开式" class="headerlink" title="驼峰式和短横线隔开式"></a>驼峰式和短横线隔开式</h2><p>HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;child&apos;, &#123;</div><div class="line">  // camelCase in JavaScript</div><div class="line">  props: [&apos;myMessage&apos;],</div><div class="line">  template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos;</div><div class="line">&#125;)</div><div class="line">&lt;!-- kebab-case in HTML --&gt;</div><div class="line">&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt;</div></pre></td></tr></table></figure>
<p>如果你使用字符串模版，则没有这些限制。尽量尊重w3c标准写代码</p>
<h2 id="动态props"><a href="#动态props" class="headerlink" title="动态props"></a>动态props</h2><p>在模板中，要动态地绑定父组件的数据到子模板的props，与绑定到任何普通的HTML特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;input v-model=&quot;parentMsg&quot;&gt;</div><div class="line">  &lt;br&gt;</div><div class="line">  &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</div><div class="line">  //使用 v-bind 的缩写语法 :&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="字面量语法-和-动态语法"><a href="#字面量语法-和-动态语法" class="headerlink" title="字面量语法 和 动态语法"></a>字面量语法 和 动态语法</h2><p>初学者常犯的一个错误是使用字面量语法传递数值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 传递了一个字符串&quot;1&quot; --&gt;</div><div class="line">&lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</div></pre></td></tr></table></figure>
<p>因为它是一个字面 prop ，它的值是字符串 “1” 而不是number。如果想传递一个实际的number，需要使用 v-bind ，从而让它的值被当作 JavaScript 表达式计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 传递实际的mumber --&gt;</div><div class="line">&lt;comp v-bind:some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</div></pre></td></tr></table></figure>
<h2 id="props是单向数据流"><a href="#props是单向数据流" class="headerlink" title="props是单向数据流"></a>props是单向数据流</h2><p>prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态</p>
<blockquote>
<p>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p>
</blockquote>
<p>父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。</p>
<p>prop作为初始值传入后，单独定义一个局部变量,而不是直接操作prop</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">props: [&apos;initialCounter&apos;],</div><div class="line">data: function () &#123;</div><div class="line">  return &#123; counter: this.initialCounter &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>prop作为初始值传入后，需要处理数据并返回，需要定义一个计算属性，处理prop</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">props: [&apos;size&apos;],</div><div class="line">computed: &#123;</div><div class="line">  normalizedSize: function () &#123;</div><div class="line">    return this.size.trim().toLowerCase()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="prop验证"><a href="#prop验证" class="headerlink" title="prop验证"></a>prop验证</h2><p>props提供了验证规格，传入数据不符合规格，就会警告</p>
<p>要指定验证规格，需要用对象的形式，而不能用字符串数组<br>type 可以是下面原生构造器：</p>
<pre><code>String
Number
Boolean
Function
Object
Array
</code></pre><p>type 也可以是一个自定义构造器函数，使用 instanceof 检测。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;example&apos;, &#123;</div><div class="line">  props: &#123;</div><div class="line">    // 基础类型检测 （`null` 意思是任何类型都可以）</div><div class="line">    propA: Number,</div><div class="line">    // 多种类型</div><div class="line">    propB: [String, Number],</div><div class="line">    // 必传且是字符串</div><div class="line">    propC: &#123;</div><div class="line">      type: String,</div><div class="line">      required: true</div><div class="line">    &#125;,</div><div class="line">    // 数字，有默认值</div><div class="line">    propD: &#123;</div><div class="line">      type: Number,</div><div class="line">      default: 100</div><div class="line">    &#125;,</div><div class="line">    // 数组／对象的默认值应当由一个工厂函数返回</div><div class="line">    propE: &#123;</div><div class="line">      type: Object,</div><div class="line">      default: function () &#123;</div><div class="line">        return &#123; message: &apos;hello&apos; &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    // 自定义验证函数</div><div class="line">    propF: &#123;</div><div class="line">      validator: function (value) &#123;</div><div class="line">        return value &gt; 10</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><p>父组件是使用 props 传递数据给子组件，子组件要把数据传递回去，就需要自定义事件</p>
<h2 id="使用v-on-绑定自定义事件"><a href="#使用v-on-绑定自定义事件" class="headerlink" title="使用v-on 绑定自定义事件"></a>使用v-on 绑定自定义事件</h2><p>每个 Vue 实例都实现了事件接口(Events interface)，即：</p>
<ul>
<li>使用 $on(eventName) 监听事件</li>
<li>使用 $emit(eventName) 触发事件</li>
</ul>
<p>父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。<br>不能用$on侦听子组件抛出的事件，而必须在模板里直接用v-on绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;counter-event-example&quot;&gt;</div><div class="line">  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;</div><div class="line">  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</div><div class="line">  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">Vue.component(&apos;button-counter&apos;, &#123;</div><div class="line">  template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</div><div class="line">  data: function () &#123;</div><div class="line">    return &#123;</div><div class="line">      counter: 0</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    increment: function () &#123;</div><div class="line">      this.counter += 1</div><div class="line">      this.$emit(&apos;increment&apos;)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;)</div><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#counter-event-example&apos;,</div><div class="line">  data: &#123;</div><div class="line">    total: 0</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    incrementTotal: function () &#123;</div><div class="line">      this.total += 1</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="给组件绑定原生事件"><a href="#给组件绑定原生事件" class="headerlink" title="给组件绑定原生事件"></a>给组件绑定原生事件</h2><p>有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on 。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;</div></pre></td></tr></table></figure>
<h2 id="使用自定义事件的表单输入组件"><a href="#使用自定义事件的表单输入组件" class="headerlink" title="使用自定义事件的表单输入组件"></a>使用自定义事件的表单输入组件</h2><p>自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input v-model=&quot;something&quot;&gt;</div></pre></td></tr></table></figure>
<p>这不过是以下示例的语法糖（效果等效）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;</div></pre></td></tr></table></figure>
<p>所以在组件中使用时，它相当于下面的简写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;custom-input v-bind:value=&quot;something&quot; v-on:input=&quot;something = arguments[0]&quot;&gt;&lt;/custom-input&gt;</div></pre></td></tr></table></figure>
<p>组件的v-model生效条件：<br>接受一个 value 属性<br>在有新的 value 时触发 input 事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currency-input&gt;</div><div class="line"></div><div class="line">//...</div><div class="line"></div><div class="line">Vue.component(&apos;currency-input&apos;, &#123;</div><div class="line">  template: &apos;\</div><div class="line">    &lt;span&gt;\</div><div class="line">      $\</div><div class="line">      &lt;input\</div><div class="line">        ref=&quot;input&quot;\</div><div class="line">        v-bind:value=&quot;value&quot;\</div><div class="line">        v-on:input=&quot;updateValue($event.target.value)&quot;\</div><div class="line">      &gt;\</div><div class="line">    &lt;/span&gt;\</div><div class="line">  &apos;,</div><div class="line">  props: [&apos;value&apos;],</div><div class="line">  methods: &#123;</div><div class="line">    // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制</div><div class="line">    updateValue: function (value) &#123;</div><div class="line">      var formattedValue = value</div><div class="line">        // 删除两侧的空格符</div><div class="line">        .trim()</div><div class="line">        // 保留 2 小数位</div><div class="line">        .slice(0, value.indexOf(&apos;.&apos;) + 3)</div><div class="line">      // 如果值不统一，手动覆盖以保持一致</div><div class="line">      if (formattedValue !== value) &#123;</div><div class="line">        this.$refs.input.value = formattedValue</div><div class="line">      &#125;</div><div class="line">      // 通过 input 事件发出数值</div><div class="line">      this.$emit(&apos;input&apos;, Number(formattedValue))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h2><p>可以使用一个空的 Vue 实例作为中央事件总线：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var bus = new Vue()</div><div class="line">// 触发组件 A 中的事件</div><div class="line">bus.$emit(&apos;id-selected&apos;, 1)</div><div class="line">// 在组件 B 创建的钩子中监听事件</div><div class="line">bus.$on(&apos;id-selected&apos;, function (id) &#123;</div><div class="line">  // ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>有现成的状态管理模式</p>
<h1 id="使用slot分发内容"><a href="#使用slot分发内容" class="headerlink" title="使用slot分发内容"></a>使用slot分发内容</h1><p>通常情况下会有如下组合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;app&gt;</div><div class="line">  &lt;app-header&gt;&lt;/app-header&gt;</div><div class="line">  &lt;app-footer&gt;&lt;/app-footer&gt;</div><div class="line">&lt;/app&gt;</div></pre></td></tr></table></figure>
<p>注意两点：<br>app 组件不知道它的挂载点会有什么内容。挂载点的内容是由<app>的父组件决定的。<br>app 组件很可能有它自己的模版。</app></p>
<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 内容分发 。Vue.js 实现了一个内容分发 API ，参照了当前 Web 组件规范草案，使用特殊的 <slot> 元素作为原始内容的插槽。</slot></p>
<h2 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h2><p>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译<br>假定模板为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;child-component&gt;</div><div class="line">  &#123;&#123; message &#125;&#125;</div><div class="line">&lt;/child-component&gt;</div></pre></td></tr></table></figure>
<p>message 是绑定到父组件的数据。</p>
<p>一个常见错误是：在父组件模板内将一个指令绑定到子组件的属性/方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 无效 --&gt;</div><div class="line">&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</div></pre></td></tr></table></figure>
<p>假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不知道子组件的状态。</p>
<p>如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;child-component&apos;, &#123;</div><div class="line">  // 有效，因为是在正确的作用域内</div><div class="line">  template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;,</div><div class="line">  data: function () &#123;</div><div class="line">    return &#123;</div><div class="line">      someChildProperty: true</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="单个slot"><a href="#单个slot" class="headerlink" title="单个slot"></a>单个slot</h2><p>除非子组件模板包含至少一个 <slot> 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。<br>最初在 <slot> 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。<br>假定 my-component 组件有下面模板：</slot></slot></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;h2&gt;我是子组件的标题&lt;/h2&gt;</div><div class="line">  &lt;slot&gt;</div><div class="line">    只有在没有要分发的内容时才会显示。</div><div class="line">  &lt;/slot&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>父组件模版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;</div><div class="line">  &lt;my-component&gt;</div><div class="line">    &lt;p&gt;这是一些初始内容&lt;/p&gt;</div><div class="line">    &lt;p&gt;这是更多的初始内容&lt;/p&gt;</div><div class="line">  &lt;/my-component&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>渲染结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h2&gt;我是子组件的标题&lt;/h2&gt;</div><div class="line">    &lt;p&gt;这是一些初始内容&lt;/p&gt;</div><div class="line">    &lt;p&gt;这是更多的初始内容&lt;/p&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="具名slot"><a href="#具名slot" class="headerlink" title="具名slot"></a>具名slot</h2><p><slot> 元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。<br>仍然可以有一个匿名 slot ，它是默认 slot ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。<br>例如，假定我们有一个 app-layout 组件，它的模板为：</slot></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">  &lt;header&gt;</div><div class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</div><div class="line">  &lt;/header&gt;</div><div class="line">  &lt;main&gt;</div><div class="line">    &lt;slot&gt;&lt;/slot&gt;</div><div class="line">  &lt;/main&gt;</div><div class="line">  &lt;footer&gt;</div><div class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</div><div class="line">  &lt;/footer&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>父组件模版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;app-layout&gt;</div><div class="line">  &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt;</div><div class="line">  &lt;p&gt;主要内容的一个段落。&lt;/p&gt;</div><div class="line">  &lt;p&gt;另一个主要段落。&lt;/p&gt;</div><div class="line">  &lt;p slot=&quot;footer&quot;&gt;这里有一些联系信息&lt;/p&gt;</div><div class="line">&lt;/app-layout&gt;</div></pre></td></tr></table></figure>
<p>渲染结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">  &lt;header&gt;</div><div class="line">    &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt;</div><div class="line">  &lt;/header&gt;</div><div class="line">  &lt;main&gt;</div><div class="line">    &lt;p&gt;主要内容的一个段落。&lt;/p&gt;</div><div class="line">    &lt;p&gt;另一个主要段落。&lt;/p&gt;</div><div class="line">  &lt;/main&gt;</div><div class="line">  &lt;footer&gt;</div><div class="line">    &lt;p&gt;这里有一些联系信息&lt;/p&gt;</div><div class="line">  &lt;/footer&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>在组合组件时，内容分发 API 是非常有用的机制。</p>
<h2 id="作用域slot"><a href="#作用域slot" class="headerlink" title="作用域slot"></a>作用域slot</h2><p>作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。<br>在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;child&quot;&gt;</div><div class="line">  &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>在父级中，具有特殊属性 scope 的 <template> 元素，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 prop 对象：</template></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">  &lt;child&gt;</div><div class="line">    &lt;template scope=&quot;props&quot;&gt;</div><div class="line">      &lt;span&gt;hello from parent&lt;/span&gt;</div><div class="line">      &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;</div><div class="line">    &lt;/template&gt;</div><div class="line">  &lt;/child&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>如果我们渲染以上结果，得到的输出会是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">  &lt;div class=&quot;child&quot;&gt;</div><div class="line">    &lt;span&gt;hello from parent&lt;/span&gt;</div><div class="line">    &lt;span&gt;hello from child&lt;/span&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;my-awesome-list :items=&quot;items&quot;&gt;</div><div class="line">  &lt;!-- 作用域插槽也可以是具名的 --&gt;</div><div class="line">  &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt;</div><div class="line">    &lt;li class=&quot;my-fancy-item&quot;&gt;&#123;&#123; props.text &#125;&#125;&lt;/li&gt;</div><div class="line">  &lt;/template&gt;</div><div class="line">&lt;/my-awesome-list&gt;</div></pre></td></tr></table></figure>
<p>列表组件的模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">  &lt;slot name=&quot;item&quot;</div><div class="line">    v-for=&quot;item in items&quot;</div><div class="line">    :text=&quot;item.text&quot;&gt;</div><div class="line">    &lt;!-- 这里写入备用内容 --&gt;</div><div class="line">  &lt;/slot&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><p>通过使用保留的 <component> 元素，动态地绑定到它的 is 特性，我们让多个组件可以使用同一个挂载点，并动态切换：</component></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: &apos;#example&apos;,</div><div class="line">  data: &#123;</div><div class="line">    currentView: &apos;home&apos;</div><div class="line">  &#125;,</div><div class="line">  components: &#123;</div><div class="line">    home: &#123; /* ... */ &#125;,</div><div class="line">    posts: &#123; /* ... */ &#125;,</div><div class="line">    archive: &#123; /* ... */ &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">&lt;component v-bind:is=&quot;currentView&quot;&gt;</div><div class="line">  &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;</div><div class="line">&lt;/component&gt;</div></pre></td></tr></table></figure>
<p>也可以直接绑定到组件对象上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var Home = &#123;</div><div class="line">  template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;</div><div class="line">&#125;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: &apos;#example&apos;,</div><div class="line">  data: &#123;</div><div class="line">    currentView: Home</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="keep-alive指令"><a href="#keep-alive指令" class="headerlink" title="keep-alive指令"></a>keep-alive指令</h2><p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数：</p>
<p><keep-alive><br>  <component :is="currentView"><br>    <!-- 非活动组件将被缓存！ --><br>  </component><br></keep-alive></p>
<h1 id="编写可复用组件"><a href="#编写可复用组件" class="headerlink" title="编写可复用组件"></a>编写可复用组件</h1><p>在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。<br>Vue 组件的 API 来自三部分 - props, events 和 slots ：<br>Props 允许外部环境传递数据给组件<br>Events 允许组件触发外部环境的副作用<br>Slots 允许外部环境将额外的内容组合在组件中。<br>使用 v-bind 和 v-on 的简写语法，模板的缩进清楚且简洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;my-component</div><div class="line">  :foo=&quot;baz&quot;</div><div class="line">  :bar=&quot;qux&quot;</div><div class="line">  @event-a=&quot;doThis&quot;</div><div class="line">  @event-b=&quot;doThat&quot;</div><div class="line">&gt;</div><div class="line">  &lt;img slot=&quot;icon&quot; src=&quot;...&quot;&gt;</div><div class="line">  &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt;</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure>
<h1 id="子组件索引"><a href="#子组件索引" class="headerlink" title="子组件索引"></a>子组件索引</h1><p>尽管有 props 和 events ，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个索引 ID 。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;parent&quot;&gt;</div><div class="line">  &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">var parent = new Vue(&#123; el: &apos;#parent&apos; &#125;)</div><div class="line">// 访问子组件</div><div class="line">var child = parent.$refs.profile</div></pre></td></tr></table></figure>
<p>当 ref 和 v-for 一起使用时， ref 是一个数组或对象，包含相应的子组件。<br>$refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs 。</p>
<h1 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h1><p>在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单， Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：<br>Vue.component(‘async-example’, function (resolve, reject) {<br>  setTimeout(function () {<br>    // Pass the component definition to the resolve callback<br>    resolve({<br>      template: ‘<div>I am async!</div>‘<br>    })<br>  }, 1000)<br>})<br>工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123;</div><div class="line">  // 这个特殊的 require 语法告诉 webpack</div><div class="line">  // 自动将编译后的代码分割成不同的块，</div><div class="line">  // 这些块将通过 Ajax 请求自动下载。</div><div class="line">  require([&apos;./my-async-component&apos;], resolve)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Vue.component(</div><div class="line">  &apos;async-webpack-example&apos;,</div><div class="line">  () =&gt; System.import(&apos;./my-async-component&apos;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>如果你是 Browserify 用户,可能就无法使用异步组件了,它的作者已经表明 Browserify 是不支持异步加载的。Browserify 社区发现 一些解决方法，可能有助于已存在的复杂应用。对于其他场景，我们推荐简单实用 Webpack 构建，一流的异步支持</p>
<h1 id="组件命名约定"><a href="#组件命名约定" class="headerlink" title="组件命名约定"></a>组件命名约定</h1><p>当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 。Vue 不关心这个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 在组件定义中</div><div class="line">components: &#123;</div><div class="line">  // 使用 kebab-case 形式注册</div><div class="line">  &apos;kebab-cased-component&apos;: &#123; /* ... */ &#125;,</div><div class="line">  // register using camelCase</div><div class="line">  &apos;camelCasedComponent&apos;: &#123; /* ... */ &#125;,</div><div class="line">  // register using TitleCase</div><div class="line">  &apos;TitleCasedComponent&apos;: &#123; /* ... */ &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 HTML 模版中，请使用 kebab-case 形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 在HTML模版中始终使用 kebab-case --&gt;</div><div class="line">&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;</div><div class="line">&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;</div><div class="line">&lt;title-cased-component&gt;&lt;/title-cased-component&gt;</div></pre></td></tr></table></figure>
<p>当使用字符串模式时，可以不受 HTML 的 case-insensitive 限制。这意味实际上在模版中，你可以使用 camelCase 、 TitleCase 或者 kebab-case 来引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 在字符串模版中可以用任何你喜欢的方式! --&gt;</div><div class="line">&lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">&lt;myComponent&gt;&lt;/myComponent&gt;</div><div class="line">&lt;MyComponent&gt;&lt;/MyComponent&gt;</div></pre></td></tr></table></figure>
<p>如果组件未经 slot 元素传递内容，你甚至可以在组件名后使用 / 使其自闭合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;my-component/&gt;</div></pre></td></tr></table></figure></p>
<p>当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。</p>
<h1 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h1><p>组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以：</p>
<pre><code>name: &apos;unique-name-of-my-component&apos;
</code></pre><p>当你利用Vue.component全局注册了一个组件, 全局的ID作为组件的 name 选项，被自动设置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;unique-name-of-my-component&apos;, &#123;</div><div class="line">  // ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果你不谨慎, 递归组件可能导致死循环:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name: &apos;stack-overflow&apos;,</div><div class="line">template: &apos;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&apos;</div></pre></td></tr></table></figure></p>
<p>上面组件会导致一个错误 “max stack size exceeded” ，所以要确保递归调用有终止条件 (比如递归调用时使用 v-if 并让他最终返回 false )。</p>
<h1 id="组件间的循环引用"><a href="#组件间的循环引用" class="headerlink" title="组件间的循环引用"></a>组件间的循环引用</h1><p>假设你正在构建一个文件目录树，像在Finder或文件资源管理器中。你可能有一个 tree-folder组件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;</div><div class="line">  &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt;</div><div class="line">  &lt;tree-folder-contents :children=&quot;folder.children&quot;/&gt;</div><div class="line">&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p>然后 一个tree-folder-contents组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li v-for=&quot;child in children&quot;&gt;</div><div class="line">    &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt;</div><div class="line">    &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt;</div><div class="line">  &lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>When you look closely, you’ll see that these components will actually be each other’s descendent and ancestor in the render tree - a paradox! When registering components globally with Vue.component, this paradox is resolved for you automatically. If that’s you, you can stop reading here.<br>当你仔细看时，会发现在渲染树上这两个组件同时为对方的父节点和子节点–这点是矛盾的。当使用Vue.component将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾，如果你是这样做的，就不用继续往下看了。<br>然而，如果你使用诸如Webpack或者Browserify之类的模块化管理工具来requiring/importing组件的话，就会报错了：<br>Failed to mount component: template or render function not defined.<br>为了解释为什么会报错，简单的将上面两个组件称为 A 和 B ，模块系统看到它需要 A ，但是首先 A 需要 B ，但是 B 需要 A， 而 A 需要 B，陷入了一个无限循环，因此不知道到底应该先解决哪个。要解决这个问题，我们需要在其中一个组件中（比如 A ）告诉模块化管理系统，“A 虽然需要 B ，但是不需要优先导入 B”<br>在我们的例子中，我们选择在tree-folder 组件中来告诉模块化管理系统循环引用的组件间的处理优先级，我们知道引起矛盾的子组件是tree-folder-contents，所以我们在beforeCreate 生命周期钩子中去注册它：<br>beforeCreate: function () {<br>  this.$options.components.TreeFolderContents = require(‘./tree-folder-contents.vue’)<br>}<br>问题解决了。</p>
<h1 id="内联模版"><a href="#内联模版" class="headerlink" title="内联模版"></a>内联模版</h1><p>如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;my-component inline-template&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;p&gt;These are compiled as the component&apos;s own template.&lt;/p&gt;</div><div class="line">    &lt;p&gt;Not parent&apos;s transclusion content.&lt;/p&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<p>但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素。</p>
<h1 id="X-Templates"><a href="#X-Templates" class="headerlink" title="X-Templates"></a>X-Templates</h1><p>另一种定义模版的方式是在 JavaScript 标签里使用 text/x-template 类型，并且指定一个id。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;</div><div class="line">  &lt;p&gt;Hello hello hello&lt;/p&gt;</div><div class="line">&lt;/script&gt;</div><div class="line">Vue.component(&apos;hello-world&apos;, &#123;</div><div class="line">  template: &apos;#hello-world-template&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。</p>
<h1 id="对低开销的静态组件使用-v-once"><a href="#对低开销的静态组件使用-v-once" class="headerlink" title="对低开销的静态组件使用 v-once"></a>对低开销的静态组件使用 v-once</h1><p>尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;terms-of-service&apos;, &#123;</div><div class="line">  template: &apos;\</div><div class="line">    &lt;div v-once&gt;\</div><div class="line">      &lt;h1&gt;Terms of Service&lt;/h1&gt;\</div><div class="line">      ... a lot of static content ...\</div><div class="line">    &lt;/div&gt;\</div><div class="line">  &apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/vue/" rel="tag"># vue</a>
          
            <a href="/tags/data函数/" rel="tag"># data函数</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/13/vue/Vue表单控件数据绑定/" rel="prev" title="Vue表单控件数据绑定">
                Vue表单控件数据绑定 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="ChrisLanbo" />
          <p class="site-author-name" itemprop="name">ChrisLanbo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#组件的使用"><span class="nav-number">1.</span> <span class="nav-text">组件的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#局部注册"><span class="nav-number">1.1.</span> <span class="nav-text">局部注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM模版"><span class="nav-number">1.2.</span> <span class="nav-text">DOM模版</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#data必须是函数"><span class="nav-number">1.3.</span> <span class="nav-text">data必须是函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件通信"><span class="nav-number">1.4.</span> <span class="nav-text">组件通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Prop"><span class="nav-number">2.</span> <span class="nav-text">Prop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用props传递数据"><span class="nav-number">2.1.</span> <span class="nav-text">使用props传递数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#驼峰式和短横线隔开式"><span class="nav-number">2.2.</span> <span class="nav-text">驼峰式和短横线隔开式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态props"><span class="nav-number">2.3.</span> <span class="nav-text">动态props</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面量语法-和-动态语法"><span class="nav-number">2.4.</span> <span class="nav-text">字面量语法 和 动态语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#props是单向数据流"><span class="nav-number">2.5.</span> <span class="nav-text">props是单向数据流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prop验证"><span class="nav-number">2.6.</span> <span class="nav-text">prop验证</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义事件"><span class="nav-number">3.</span> <span class="nav-text">自定义事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用v-on-绑定自定义事件"><span class="nav-number">3.1.</span> <span class="nav-text">使用v-on 绑定自定义事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给组件绑定原生事件"><span class="nav-number">3.2.</span> <span class="nav-text">给组件绑定原生事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用自定义事件的表单输入组件"><span class="nav-number">3.3.</span> <span class="nav-text">使用自定义事件的表单输入组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非父子组件通信"><span class="nav-number">3.4.</span> <span class="nav-text">非父子组件通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用slot分发内容"><span class="nav-number">4.</span> <span class="nav-text">使用slot分发内容</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译作用域"><span class="nav-number">4.1.</span> <span class="nav-text">编译作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单个slot"><span class="nav-number">4.2.</span> <span class="nav-text">单个slot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#具名slot"><span class="nav-number">4.3.</span> <span class="nav-text">具名slot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域slot"><span class="nav-number">4.4.</span> <span class="nav-text">作用域slot</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态组件"><span class="nav-number">5.</span> <span class="nav-text">动态组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#keep-alive指令"><span class="nav-number">5.1.</span> <span class="nav-text">keep-alive指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编写可复用组件"><span class="nav-number">6.</span> <span class="nav-text">编写可复用组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#子组件索引"><span class="nav-number">7.</span> <span class="nav-text">子组件索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步组件"><span class="nav-number">8.</span> <span class="nav-text">异步组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组件命名约定"><span class="nav-number">9.</span> <span class="nav-text">组件命名约定</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#递归组件"><span class="nav-number">10.</span> <span class="nav-text">递归组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组件间的循环引用"><span class="nav-number">11.</span> <span class="nav-text">组件间的循环引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内联模版"><span class="nav-number">12.</span> <span class="nav-text">内联模版</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#X-Templates"><span class="nav-number">13.</span> <span class="nav-text">X-Templates</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对低开销的静态组件使用-v-once"><span class="nav-number">14.</span> <span class="nav-text">对低开销的静态组件使用 v-once</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChrisLanbo</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
